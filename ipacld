#!/usr/local/bin/lua

syslog  = require "org.conman.syslog"
net     = require "org.conman.net"
errno   = require "org.conman.errno"
proc    = require "org.conman.process"
sig     = require "org.conman.process".sig
ipacl_s = require "org.conman.net.ipacl_s"

-- *********************************************************************

function log_success(remote,cred,addr,proto)
  syslog('notice',string.format("success: rem=%s uid=%s gid=%s family=%s addr=%s proto=%s port=%s",
  		tostring(remote),
      		cred.uid,
      		cred.gid,
      		addr.family,
      		addr.addr,
		proto,
      		addr.port
      		))      		
end

-- *********************************************************************

function log_failure(point,remote,cred,addr,proto,err)
  local remote = remote or "(unknown)"
  local cred   = cred   or { uid = '(unk)' , gid = '(unk)' , pid = 0 }
  local addr   = addr   or { family = '(unk)' , addr = '(unk)' , port = '(unk)'}
  local proto  = proto  or 0

  syslog('err',string.format("failure: at=%q err=%q rem=%s uid=%s gid=%s family=%s addr=%s proto=%s port=%s",
		point,
  		errno.strerror(err),
  		tostring(remote),
      		cred.uid,
      		cred.gid,
      		addr.family,
      		addr.addr,
		proto,
      		addr.port
      		))
end

-- *********************************************************************

function main(req)
  local remote
  local cred
  local addr
  local proto
  local sock
  local err
  local _

  if sig.caught(sig.INT) then
    req:close()
    sig.default(sig.INT)
    proc.kill(proc.PID,sig.INT)
    proc.exit(1)
  end
  
  remote,cred,addr,proto,err = req:read()
  
  if err ~= 0 then
    if err ~= errno.EINTR then
      syslog('err',string.format("req:read() = %s",errno.strerror(err)))
    end
    return main(req)
  end
  
  if request_okay(cred,addr,proto) then
    sock,err = net.socket(addr.family,proto)
    if err ~= 0 then
      log_failure('socket',remote,cred,addr,proto,err)
      req:send_err(remote,err)
      return main(req)
    end
    
    _,err = sock:reuse()
    if err ~= 0 then
      log_failure('reuse',remote,cred,addr,proto,err)
      req:send_err(remote,err)
      sock:close()
      return main(req)
    end
    
    err = sock:bind(addr)
    if err == 0 then
      log_success(remote,cred,addr,proto)
      req:send_fd(remote,sock:fd())
    else
      log_failure('bind',remote,cred,addr,proto,err)
      req:send_err(remote,err)
    end
    
    sock:close()
  else
    log_failure('request_okay',remote,cred,addr,proto,errno.EPERM)
    req:send_err(remote,errno.EPERM)
  end
  
  return main(req)
end

-- *********************************************************************

if not pcall(dofile,"/home/spc/source/daemon/acl/version.lua") then
  VERSION = 0
end

syslog.open('ipacld','daemon')
syslog('notice',"ipacld " .. VERSION .. " starting up")

if arg[1] == nil then
  dofile("ipacl.lua")
else
  dofile(arg[1])
end

sig.catch(sig.INT)

local sock,err = ipacl_s.open()
if err ~= 0 then
  syslog('err',string.format("ipacl_s.open() = %s",errno.strerror(err)))
  os.exit(1)
end

main(sock)
